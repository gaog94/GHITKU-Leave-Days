[{"name": "app.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri May  9 23:39:29 2025\n\n@author: galengao\n\"\"\"\n\nfrom shiny import App, reactive, render, ui\n\nfrom urllib.request import urlretrieve\n\nimport datetime\nfrom collections import Counter\n\nimport pandas as pd\n\ndef generate_url(startdate, enddate, passkey):\n    # format passkey to account for whitespace\n    passkey = passkey.replace(' ', '%20')\n    \n    '''Download amion datatable of interest'''\n    # Use the 625c extension to figure out wtf people are doing\n    urlstem = \"https://www.amion.com/cgi-bin/ocs?Lo={}&Rpt=625ctabs\".format(passkey)\n    \n    # If Amion API still works this way, can consider future upgrade:\n    # Request blocks 2-14 for interns & blocks 1-13 for seniors\n    # Example w/academic year 2023 as such:\n    # https://www.amion.com/cgi-bin/ocs?Lo=***&Rpt=625c&Blks=1-13&Syr=2023\n    \n    # parse date information\n    y, m, d = startdate.strftime('%y'), startdate.month, startdate.day\n    delta = (enddate - startdate).days\n\n    datestring = \"&Day={}&Month={}-{}&Days={}\".format(d, m, y, delta)\n\n    return urlstem + datestring\n\ndef download_df(academicYear, passkey):\n    # need to adjust these thresholds for intern vs senior calendars\n    # will also try to get rid of hard-coded dates in a later patch\n    if academicYear == 'AY22':\n        startdate = datetime.datetime(2022, 6, 24) # '2022-06-24'\n        enddate = datetime.datetime(2023, 6, 27) # '2023-06-27'\n    if academicYear == 'AY23':\n        startdate = datetime.datetime(2023, 6, 28) # '2023-06-28'\n        enddate = datetime.datetime(2024, 6, 30) # '2024-06-30'\n    elif academicYear == 'AY24':\n        startdate = datetime.datetime(2024, 7, 1) # '2024-07-01'\n        enddate = datetime.datetime(2025, 6, 29) # '2025-06-29'\n    elif academicYear == 'AY25':\n        startdate = datetime.datetime(2025, 6, 30) # '2025-06-30'\n        enddate = datetime.datetime(2026, 6, 29) # '2026-06-29'\n    else: # if invalid academic year given, then return ancient year for an error\n        startdate = datetime.datetime(1, 1, 1)\n        enddate = datetime.datetime(1, 1, 2)\n    \n    # pull data from amion using given academic year and passkey\n    url = generate_url(startdate, enddate, passkey)\n    path, headers = urlretrieve(url)\n\n    # attempt to parse results and return accordingly\n    try:\n        df = pd.read_table(path, skiprows=7, header=None, \\\n                       usecols=[0,3,6,7,8,9,15,16])\n    \n    except pd.errors.EmptyDataError:\n        return pd.DataFrame([])\n    \n    else:\n        # rename columns\n        columns = ['Name', 'Assignment', 'Date', 'Start', 'Stop', 'Role', 'Type', 'Assgn']\n        df.columns = columns\n    \n        # Get rid of role == null columns and role == \"Services\" (e.g. \"H MICU A\")\n        df = df[~df.Role.isnull()]\n        df = df[df.Role != 'Services']\n        df = df[df.Role.str[-1] != '*']\n    \n        # replace instances of \"(\" and \")\" with \"'\" to encode nicknames the same way\n        df['Name'] = df.Name.str.replace('\\'', '').str.replace('\\\"', '')\n    \n        return df\n        \n\ndef generate_rezzy_dictionary(df):\n    # Sorting code\n    listRoles = ['IM R1', 'IM R2', 'IM R3', 'RM R1', 'Psych R1', 'Anes R1', \\\n                 'FM R1', 'FM R2', 'EM UW', 'EM UW R1', 'EM Madigan R1', 'IM R4']\n    roleDict = {x:y for x,y in zip(listRoles, range(len(listRoles)))}\n    \n    # get only role assignments from the first date in the date range\n    # this avoids duplication of \n    df_x = df[df.Date == df.Date.iloc[0]]\n    \n    # drop duplicates name entries and then sort first by role (e.g. PGY year)\n    # and then alphebetically by name\n    df_x = df_x[~df_x.Name.duplicated()].sort_values([\"Role\", \"Name\"], \\\n                                                 key=lambda x: x.map(roleDict))\n    \n    masterDict = {r:{x:x for x in df_x[df_x.Role == r]['Name']} \\\n                  for r in df_x.Role.unique()}\n    \n    return masterDict\n\ndef check_delinquency(df, rezzy):\n    '''Note, this script assumes all weekend dates denoted \"Vac\" are denoted in\n    error, as the working assumption is that we get 20 vacation days to use on\n    weekdays each academic year. Thus, if you use a vacation day during a \n    weekend on an admitting block, then this app will undercount your vacation\n    days'''\n    # List of days that will get penalized\n    # Note rezzies are NOT penalized for conferences, interviews, retreats/RATL, etc\n    penalties = ['Vac', 'Sick', 'LWOP', 'Jury Duty', 'Bereavement', 'Personal Holiday']\n    penalties += [x+'*' for x in penalties] # account for Vac*, Sick*, and Bereavement*\n\n    df_x = df[df.Name == rezzy]\n    # df_x = df_x.dropna()\n    df_x = df_x[df_x.Assgn.isin(penalties)]\n\n    # Strip asterisks for any labels that contain asterisks\n    df_x.Assignment = [x.strip('*') for x in df_x.Assignment]\n\n    # Drop any potential duplicate dates (e.g. in case AM & PM are labeled in independent rows)\n    df_x = df_x[~df_x.Date.duplicated(keep='first')]\n\n    # Mask Sick & Bereavement under same label to attempt to protect privacy\n    df_x.Assignment = ['Sick/Bereavement' if x in  ['Bereavement', 'Sick'] else x for x in df_x.Assignment]\n\n    # Drop vacation days used used on weekend days:\n    \n    # Convert index dates to [DOW Month DD, YYYY] format & add DOW column\n    df_out = df_x[['Assignment', 'Date', 'Assgn']]\n    dates, dsow = [], []\n    for d in df_out.Date:\n        if type(d) is str:\n            date = datetime.datetime.strptime(d, '%m-%d-%y') # -> datetime obj\n            textdate = date.strftime(\"%A %b %d, %Y\") # -> new string\n            dates.append(textdate)\n            dsow.append(date.strftime(\"%A\"))\n        else:\n            dates.append('')\n            dsow.append('')\n    df_out.index = dates\n    df_out['DOW'] = dsow\n\n    # Split df_out into vacation and non-vacation days, remove Sat/Sun from vacation\n    # days, then re-combine into df_out\n    df_nonvac = df_out[df_out.Assignment != 'Vac']\n    df_vac = df_out[df_out.Assignment == 'Vac']\n    df_vac = df_vac[~df_vac.DOW.isin(['Saturday', 'Sunday'])]\n    df_out = pd.concat([df_nonvac, df_vac], axis=0)[['Assignment', 'Date']]\n\n    # Sort Dates by chronological order\n    df_out['Year'] = df_out.Date.str.split('-').str[2].astype(int)\n    df_out['Month'] = df_out.Date.str.split('-').str[0].astype(int)\n    df_out['Day'] = df_out.Date.str.split('-').str[1].astype(int)\n    df_out = df_out.sort_values(['Year', 'Month', 'Day'])\n    \n    # drop 'Year', 'Month', 'Day', and 'Date' columns for sleek presentation\n    df_out = df_out[['Assignment']]\n\n    # reset index to be numerical for styles\n    df_out = df_out.reset_index()\n    df_out.columns = ['Date', 'Assignment']\n\n    # Create coloring guide for output dataframe\n    classes = ['Vac', 'Personal Holiday', 'Sick/Bereavement', 'LWOP', 'Jury Duty']\n    colors = ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e']\n    styles = [{\"class\": \"text-center\", \"color\": \"white\"}]\n    for absentType, color in zip(classes, colors):\n        rowIndices = list(df_out[df_out['Assignment'] == absentType].index)\n        styles.append({\n            \"rows\": rowIndices,\n            \"cols\": [1],\n            \"style\": {\"background-color\": color}\n        })\n        \n    return df_out, styles\n\ndef summarize_delinquency(df_out, academicYear):\n    classes = ['Vacation', 'Personal', 'Sick/Bereavement', 'Leave W/O Pay', 'Jury Duty']\n    mapping = {'Vac': 'Vacation', 'LWOP': 'Leave W/O Pay', 'Personal Holiday': 'Personal'}\n    counts = Counter(df_out['Assignment'].replace(mapping))\n    df_s = pd.DataFrame(counts, index=[academicYear])\n    for c in classes:\n        if c not in df_s.columns:\n            df_s[c] = 0\n            \n    return df_s\n\napp_ui = ui.page_fluid(\n    ui.row(\n        ui.column(4, \n                  ui.h4(\"Check your degree of delinquency:\"),\n                  \n                  # Amion password\n                  ui.input_password(\"password\", \"Amion Password:\", \"\"),  \n              \n                  # Date range\n                  ui.input_select(\n                      \"academicYear\",\n                      \"Choose an academic year:\",\n                      {\"AY22\": \"2022 - 2023\", \\\n                       \"AY23\": \"2023 - 2024\" , \\\n                       \"AY24\": \"2024 - 2025\", \\\n                       \"AY25\": \"2025 - 2026\"},\n                      selected = \"AY24\"\n                  ),\n\n                  # Submit button to populate list of residents\n                  ui.input_action_button(\"submit_AY\", \"Submit Year\"),  \n              \n                  ui.HTML(\"<br><br><br>\"),  \n              \n                  ui.input_select(  \n                      \"rezzies\",  \n                      'Is ___ a \"delinquent?\"',  \n                      [],\n                      multiple=False,\n                      width=\"100%\",\n                      size=12,\n                  ),  \n              \n                  ui.input_action_button(\"submit_resident\", \"Start Inquisition!\"),  \n                  \n                  ui.HTML(\"<br><br><br>\"),  \n                  \n                  ui.input_text(\"alert\", label=\"\"),\n\n              \n        ),\n    \n        ui.column(8,\n                  ui.h2(\"Summary of Days of Leave\"),\n                  ui.output_data_frame(\"DQ_aggregate\"), # change this to summary\n                  ui.output_text_verbatim(\"summary\", placeholder=False),\n                  ui.output_text(\"asteriskOne\"),\n                  ui.output_text(\"asteriskTwo\"),\n                  \n                  ui.HTML(\"<br> <br>\"),\n                  ui.output_data_frame(\"DQ_individual\"), # change this to individual dates\n        ),\n\n    ),\n    \n)\n\ndef server(input, output, session):\n    \n    # implement storage of data, so you only have to pull data once\n    amionData = reactive.value(pd.DataFrame({\" \": [], \"  \": []}))\n    \n    @reactive.effect()\n    @reactive.event(input.submit_AY)\n    def _():\n        df = download_df(input.academicYear(), input.password())\n        amionData.set(df)\n\n\n    @reactive.effect()\n    @reactive.event(input.submit_AY)\n    def update_select_rezzies():\n        df = amionData.get()\n        if len(df) == 0:\n            ui.update_text('alert', value='Error: check password!')\n        else:\n            masterDict = generate_rezzy_dictionary(df)\n            ui.update_select(\"rezzies\", choices=masterDict)\n        \n    @reactive.Calc\n    @reactive.event(input.submit_resident)\n    def data():\n        try:\n            df_out, styles = check_delinquency(amionData.get(), input.rezzies())\n        except AttributeError:\n            df_out = pd.DataFrame({\" \": [], \"  \": []})\n            styles = {}\n        \n        return df_out, styles\n\n    @render.data_frame\n    def DQ_individual():\n        df_out, styles = data()\n        if len(df_out) == 0:\n            ui.update_text('alert', value='Error: Not all inputs provided!')\n        else:\n            return render.DataGrid(\n                df_out,\n                filters=False,\n                summary=False,\n                width=\"100%\",\n                styles=styles,\n            )\n\n    # @output\n    @render.data_frame\n    def DQ_aggregate():\n        df = data()[0]\n        if len(df) == 0:\n            ui.update_text('alert', value='Error: Not all inputs provided!')\n        else:\n            columns = ['Vacation', 'Personal', 'Sick/Bereavement', 'Leave W/O Pay', 'Jury Duty']\n            legend = pd.DataFrame([20, '1*', '17/3-5**', 'NA', 'NA'], columns=['Max Per Year'], \\\n                          index = columns).T\n                \n            df_s = summarize_delinquency(data()[0], input.academicYear())\n            df_s = pd.concat([legend, df_s]).reset_index()\n            df_s.columns = [' '] + columns\n            \n            colors = ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e']\n    \n            return render.DataGrid(\n                df_s,\n                styles=[\n                    {\n                        'rows': [1],\n                        'cols': [i+1],\n                        'style': {'background-color': color},\n                    } for i, color in enumerate(colors)]\n                    \n            )\n\n    @render.text\n    @reactive.event(input.submit_resident)\n    def summary():\n        df = data()[0]\n        if len(df) == 0:\n            ui.update_text('alert', value='Error: Not all inputs provided!')\n        else:\n            df = summarize_delinquency(df, input.academicYear()).T\n            s = sum(df[input.academicYear()])\n            return \"%s has used %d days of leave out of 35 advised (per annum)\" \\\n                % (input.rezzies(), s)\n    \n    @render.text\n    @reactive.event(input.submit_resident)\n    def asteriskOne():\n        if len(data()[0]) == 0:\n            ui.update_text('alert', value='Error: Not all inputs provided!')\n        else:\n            return \"*1 personal day is allowed per calendar year (NOT academic year)\"\n\n    @render.text\n    @reactive.event(input.submit_resident)\n    def asteriskTwo():\n        if len(data()[0]) == 0:\n            ui.update_text('alert', value='Error: Not all inputs provided!')\n        else:\n            return \"**RFPU grants 17 days of sick time per academic year. RFPU \\\n                also grants 5 days of bereavement leave a year (or 3 if no \\\n                significant travel is required)\"\n    \napp = App(app_ui, server)", "type": "text"}, {"name": "sandbox.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri May  9 22:11:19 2025\n\n@author: galengao\n\"\"\"\nimport pandas as pd\nimport numpy as np\n\nimport datetime\n\ndf = pd.read_csv('~/Downloads/Amion_Report_625_1-1-24_to_12-30-24.csv', \\\n                   skiprows=7, header=None, usecols=[0,3,6,7,8,9,15,16])\ncolumns = ['Name', 'Assignment', 'Date', 'Start', 'Stop', 'Role', 'Type', 'Assgn']\ndf.columns = columns\n\n# Get names of all IM residents\ndf_x = df[df.Role.isin(['IM R1', 'IM R2', 'IM R3'])]\nrezzies = np.sort(df_x.Name.unique())\n\n# dive into 1 rezzy's clinic numbers\nx = 'Zhang, Michelle'\n\n# List of days that will get penalized\n# Note rezzies are NOT penalized for conferences, interviews, retreats/RATL, etc\npenalties = ['Vac', 'Sick', 'LWOP', 'Jury Duty', 'Bereavement', 'Personal Holiday']\npenalties += [x+'*' for x in penalties] # account for Vac*, Sick*, and Bereavement*\n\ndf_x = df[df.Name == x]\ndf_x = df_x.dropna()\ndf_x = df_x[df_x.Assgn.isin(penalties)]\n\n# Strip asterisks for any labels that contain asterisks\ndf_x.Assignment = [x.strip('*') for x in df_x.Assignment]\n\n# Drop any potential duplicate dates (e.g. in case AM & PM are labeled in independent rows)\ndf_x = df_x[~df_x.Date.duplicated(keep='first')]\n\n# Hide Sick/Bereavement\ndf_x.Assignment = ['Sick/Bereavement' if x in  ['Bereavement', 'Sick'] else x for x in df_x.Assignment]\n\n# Check Vacations are not used on weekend days\n# Note, if you somehow game the system and used a vacation day on an admitting block\n# then you will be falsely granted a vacation date (i.e. this script assumes all\n# weekend dates designated as \"Vac\" are designated in error, as we get 20 vacation\n# days to use on weekdays throughout the year)\n\n# Convert index dates to [DOW Month DD, YYYY] format & add DOW column\ndf_out = df_x[['Assignment', 'Date', 'Assgn']]\ndates, dsow = [], []\nfor d in df_out.Date:\n    if type(d) is str:\n        date = datetime.datetime.strptime(d, '%m-%d-%y') # -> datetime obj\n        textdate = date.strftime(\"%A %b %d, %Y\") # -> new string\n        dates.append(textdate)\n        dsow.append(date.strftime(\"%A\"))\n    else:\n        dates.append('')\n        dsow.append('')\ndf_out.index = dates\ndf_out['DOW'] = dsow\n\n# Split df_out into vacation and non-vacation days, remove Sat/Sun from vacation\n# days, then re-combine into df_out\ndf_nonvac = df_out[df_out.Assignment != 'Vac']\ndf_vac = df_out[df_out.Assignment == 'Vac']\ndf_vac = df_vac[~df_vac.DOW.isin(['Saturday', 'Sunday'])]\ndf_out = pd.concat([df_nonvac, df_vac], axis=0)[['Assignment']]\n\n# Create coloring guide for output dataframe\nclasses = ['Vac', 'Personal Holiday', 'Sick/Bereavement', 'LWOP', 'Jury Duty']\ncolors = ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e']\nstyles = [{\"class\": \"text-center\", \"color\": \"white\"}]\nfor absentType, color in zip(classes, colors):\n    rowIndices = list(df_out[df_out['Assignment'] == absentType].index)\n    styles.append({\n        \"rows\": rowIndices,\n        \"cols\": [0],\n        \"style\": {\"background-color\": color}\n    })\n\n\n\n# Craft Output Summary Dataframe\nlegend = pd.DataFrame([20, '1*', 20, 'NA', 'NA'], columns=['Max Per Year'], \\\n                      index = ['Vacation', 'Personal', 'Sick/Bereavement', \\\n                       'Leave W/O Pay', 'Jury Duty']).T\n    \n# df_s = legend.T\n# len(df_x.Assignment)\n# df_s[x] = []\n\n# Craft Output List of Penalized Dates", "type": "text"}]